generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  user
  admin
}

model account {
  id                    String    @id @default(cuid())
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime? @db.Timestamptz(6)
  refreshTokenExpiresAt DateTime? @db.Timestamptz(6)
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now()) @db.Timestamptz(6)
  updatedAt             DateTime  @db.Timestamptz(6)
  user                  user      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)
}

model apiKey {
  id        String    @id @default(cuid())
  name      String
  hashedKey String    @unique
  userId    String
  expiresAt DateTime? @db.Timestamp(6)
  createdAt DateTime  @default(now()) @db.Timestamp(6)
  updatedAt DateTime  @default(now()) @db.Timestamp(6)
  user      user      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)
}

model apikey {
  id                  String    @id @default(cuid())
  name                String?
  start               String?
  prefix              String?
  key                 String
  userId              String
  refillInterval      Int?
  refillAmount        Int?
  lastRefillAt        DateTime? @db.Timestamptz(6)
  enabled             Boolean?
  rateLimitEnabled    Boolean?
  rateLimitTimeWindow Int?
  rateLimitMax        Int?
  requestCount        Int?
  remaining           Int?
  lastRequest         DateTime? @db.Timestamptz(6)
  expiresAt           DateTime? @db.Timestamptz(6)
  createdAt           DateTime  @db.Timestamptz(6)
  updatedAt           DateTime  @db.Timestamptz(6)
  permissions         String?
  metadata            String?
  user                user      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)
}

model invitation {
  id             String       @id @default(cuid())
  organizationId String
  email          String
  role           String?
  status         String
  expiresAt      DateTime     @db.Timestamptz(6)
  inviterId      String
  user           user         @relation(fields: [inviterId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  organization   organization @relation(fields: [organizationId], references: [id], onDelete: Cascade, onUpdate: NoAction)
}

model member {
  id             String       @id @default(cuid())
  organizationId String
  userId         String
  role           String
  createdAt      DateTime     @db.Timestamptz(6)
  organization   organization @relation(fields: [organizationId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  user           user         @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)
}

model organization {
  id         String       @id @default(cuid())
  name       String
  slug       String       @unique
  logo       String?
  createdAt  DateTime     @db.Timestamptz(6)
  metadata   String?
  invitation invitation[]
  member     member[]
}

model rateLimit {
  id          String @id @default(cuid())
  key         String
  count       Int
  lastRequest BigInt
}

model session {
  id                   String   @id @default(cuid())
  expiresAt            DateTime @db.Timestamptz(6)
  token                String   @unique
  createdAt            DateTime @default(now()) @db.Timestamptz(6)
  updatedAt            DateTime @db.Timestamptz(6)
  ipAddress            String?
  userAgent            String?
  userId               String
  activeOrganizationId String?
  impersonatedBy       String?
  user                 user     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)
}

model twoFactor {
  id          String @id @default(cuid())
  secret      String
  backupCodes String
  userId      String
  user        user   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)
}

model user {
  id                 String       @id @default(cuid())
  name               String
  email              String       @unique
  emailVerified      Boolean
  image              String?
  createdAt          DateTime     @default(now()) @db.Timestamptz(6)
  updatedAt          DateTime     @default(now()) @db.Timestamptz(6)
  twoFactorEnabled   Boolean?
  subscriptionStatus String?
  stripeCustomerId   String?
  language           String?
  firstName          String?
  lastName           String?
  role               UserRole     @default(user)
  banned             Boolean?
  banReason          String?
  banExpires         DateTime?    @db.Timestamptz(6)
  account            account[]
  apiKey             apiKey[]
  apikey             apikey[]
  invitation         invitation[]
  member             member[]
  session            session[]
  twoFactor          twoFactor[]
}

model verification {
  id         String   @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime @db.Timestamptz(6)
  createdAt  DateTime @default(now()) @db.Timestamptz(6)
  updatedAt  DateTime @default(now()) @db.Timestamptz(6)
}

model auditLog {
  id        String   @id @default(cuid())
  eventType String
  category  String
  userId    String?
  targetId  String?
  ipAddress String?
  userAgent String?
  details   String?
  metadata  Json?
  severity  String   @default("INFO")
  status    String   @default("SUCCESS")
  timestamp DateTime @default(now()) @db.Timestamptz(6)

  @@index([userId, timestamp])
  @@index([eventType, timestamp])
  @@index([category, timestamp])
  @@index([timestamp])
}
